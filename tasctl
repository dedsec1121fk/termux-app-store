#!/data/data/com.termux/files/usr/bin/bash
set -euo pipefail

APP_NAME="termux-app-store"
CTL_NAME="tasctl"
INSTALL_DIR="$PREFIX/lib/.tas"
BIN_DIR="$PREFIX/bin"
REPO="djunekz/termux-app-store"
BIN_PATH="$INSTALL_DIR/$APP_NAME"
SYMLINK="$BIN_DIR/$APP_NAME"
TASCTL_SYMLINK="$BIN_DIR/$CTL_NAME"
GITHUB_API="https://api.github.com/repos/$REPO/releases/latest"
TASCTL_RAW="https://raw.githubusercontent.com/$REPO/main/tasctl"

R=$'\033[0m'
B=$'\033[1m'
DIM=$'\033[2m'
RED=$'\033[31m'
GREEN=$'\033[32m'
YELLOW=$'\033[33m'
CYAN=$'\033[36m'
MAGENTA=$'\033[35m'

log()    { printf " %s[*]%s %s\n" "$CYAN$B" "$R" "$*"; }
ok()     { printf " %s[✔]%s %s\n" "$GREEN$B" "$R" "$*"; }
warn()   { printf " %s[!]%s %s\n" "$YELLOW$B" "$R" "$*" >&2; }
err()    { printf " %s[✗]%s %s\n" "$RED$B" "$R" "$*" >&2; exit 1; }
info()   { printf "     %s%s%s\n" "$DIM" "$*" "$R"; }
step()   { printf "\n %s→%s %s\n" "$MAGENTA$B" "$R" "$*"; }
header() {
  local title="$1"
  local line
  line=$(printf '─%.0s' $(seq 1 ${#title}))
  printf "\n%s%s%s\n%s%s%s\n" "$CYAN$B" "$title" "$R" "$DIM" "$line" "$R"
}

banner() {
  printf "\n%s" "$CYAN$B"
  printf "       ████████╗ █████╗ ███████╗\n"
  printf "          ██╔══╝██╔══██╗██╔════╝\n"
  printf "          ██║   ███████║███████╗ \n"
  printf "          ██║   ██╔══██║╚════██║\n"
  printf "          ██║   ██║  ██║███████║\n"
  printf "          ╚═╝   ╚═╝  ╚═╝╚══════╝\n"
  printf "%s" "$R"
  printf "       %sTermux App Store Controller%s\n" "$DIM$YELLOW" "$R"
  printf "               %sby %s@djunekz%s\n\n" "$DIM$YELLOW" "$GREEN" "$R"
}

detect_arch() {
  case "$(uname -m)" in
    aarch64) echo "termux-app-store-aarch64" ;;
    armv7l|armv8l) echo "termux-app-store-arm" ;;
    x86_64)  echo "termux-app-store-x86_64" ;;
    i686|i386) echo "termux-app-store-i686" ;;
    *) err "Unsupported architecture: $(uname -m)" ;;
  esac
}

fetch_latest_tag() {
  curl -fsSL \
    -H "Accept: application/vnd.github+json" \
    "$GITHUB_API" 2>/dev/null \
    | grep '"tag_name"' \
    | head -1 \
    | sed 's/.*"tag_name": *"\([^"]*\)".*/\1/'
}

get_installed_version() {
  if [[ ! -f "$BIN_PATH" ]]; then
    echo "not installed"
    return
  fi
  local ver
  ver=$(strings "$BIN_PATH" 2>/dev/null | grep -E '^v[0-9]+\.[0-9]+' | head -1 || true)
  if [[ -n "$ver" ]]; then
    echo "$ver"
  else
    echo "installed"
  fi
}

install_app() {
  local mode="${1:-install}"
  local tag bin_name url

  step "Fetching latest release info..."
  tag=$(fetch_latest_tag)
  if [[ -z "$tag" ]]; then
    err "Cannot fetch release info. Check your internet connection."
  fi
  printf " %s[✔]%s Latest version: %s%s%s\n" "$GREEN$B" "$R" "$GREEN$B" "$tag" "$R"

  bin_name=$(detect_arch)
  url="https://github.com/$REPO/releases/download/$tag/$bin_name"

  step "Downloading $bin_name $tag..."
  info "Arch : $(uname -m)"
  info "File : $bin_name"
  info "URL  : $url"

  mkdir -p "$INSTALL_DIR"
  if curl -fL --progress-bar "$url" -o "$BIN_PATH"; then
    chmod +x "$BIN_PATH"
  else
    err "Download failed. Check your internet connection."
  fi

  step "Creating symlink..."
  ln -sf "$BIN_PATH" "$SYMLINK"
  ok "Symlink: $SYMLINK → $BIN_PATH"

  printf "\n%s  ✔ %s %s %sed successfully!%s\n" "$GREEN$B" "$APP_NAME" "$tag" "$mode" "$R"
  info "Run with: ${CYAN}$APP_NAME${R}"
  printf "\n"
}

uninstall_app() {
  banner
  header "Uninstall"

  if [[ ! -f "$BIN_PATH" ]] && [[ ! -L "$SYMLINK" ]]; then
    warn "$APP_NAME is not installed."
    return
  fi

  step "Removing symlink..."
  rm -f "$SYMLINK"
  ok "Removed: $SYMLINK"

  step "Removing binary..."
  rm -rf "$INSTALL_DIR"
  ok "Removed: $INSTALL_DIR"

  printf "\n%s  ✔ %s uninstalled successfully.%s\n\n" "$GREEN$B" "$APP_NAME" "$R"
}

cmd_doctor() {
  banner
  header "Environment Diagnosis"

  local all_ok=true

  printf "\n %sArchitecture%s\n" "$B" "$R"
  local arch bin_name
  arch=$(uname -m)
  bin_name=$(detect_arch 2>/dev/null || echo "unsupported")
  if [[ "$bin_name" != "unsupported" ]]; then
    ok "$arch → binary: $bin_name"
  else
    warn "Unsupported architecture: $arch"
    all_ok=false
  fi

  printf "\n %sPython%s\n" "$B" "$R"
  if command -v python3 >/dev/null 2>&1; then
    ok "$(python3 --version)"
    info "$(which python3)"
  elif command -v python >/dev/null 2>&1; then
    ok "$(python --version)"
    info "$(which python)"
  else
    warn "Python not found"
    info "Fix: pkg install python"
    all_ok=false
  fi

  printf "\n %spip%s\n" "$B" "$R"
  if command -v pip3 >/dev/null 2>&1; then
    ok "$(pip3 --version | awk '{print $1,$2}')"
  elif command -v pip >/dev/null 2>&1; then
    ok "$(pip --version | awk '{print $1,$2}')"
  else
    warn "pip not found"
    info "Fix: pkg install python"
    all_ok=false
  fi

  printf "\n %sTextual (TUI framework)%s\n" "$B" "$R"
  if python3 -c "import textual" >/dev/null 2>&1; then
    local txt_ver
    txt_ver=$(python3 -c "import textual; print(textual.__version__)" 2>/dev/null)
    ok "textual v$txt_ver"
  else
    warn "Textual not found"
    info "Fix: pip install textual"
    all_ok=false
  fi

  printf "\n %scurl%s\n" "$B" "$R"
  if command -v curl >/dev/null 2>&1; then
    ok "$(curl --version | head -1 | awk '{print $1,$2}')"
  else
    warn "curl not found"
    info "Fix: pkg install curl"
    all_ok=false
  fi

  printf "\n %s%s binary%s\n" "$B" "$APP_NAME" "$R"
  if [[ -f "$BIN_PATH" ]]; then
    local inst_ver
    inst_ver=$(get_installed_version)
    ok "Found: $BIN_PATH"
    info "Version: $inst_ver"
    if [[ -L "$SYMLINK" ]]; then
      ok "Symlink OK: $SYMLINK"
    else
      warn "Symlink missing: $SYMLINK"
      info "Fix: ln -sf $BIN_PATH $SYMLINK"
      all_ok=false
    fi
  else
    warn "$APP_NAME not installed"
    info "Fix: $CTL_NAME install"
    all_ok=false
  fi

  printf "\n %sTERMUX_APP_STORE_HOME%s\n" "$B" "$R"
  if [[ -n "${TERMUX_APP_STORE_HOME:-}" ]]; then
    if [[ -d "$TERMUX_APP_STORE_HOME/packages" ]]; then
      ok "Set and valid: $TERMUX_APP_STORE_HOME"
    else
      warn "Set but invalid path: $TERMUX_APP_STORE_HOME"
      info "packages/ directory not found inside it"
      all_ok=false
    fi
  else
    info "Not set (optional — uses cache if previously run)"
  fi

  printf "\n%s%s%s\n" "$DIM" "$(printf '─%.0s' $(seq 1 42))" "$R"
  if $all_ok; then
    printf " %s✔ All checks passed. Environment looks good!%s\n\n" "$GREEN$B" "$R"
  else
    printf " %s! Some issues found. See above for fixes.%s\n\n" "$YELLOW$B" "$R"
  fi
}

cmd_self_update() {
  banner
  header "Self-Update tasctl"

  step "Fetching latest tasctl from GitHub..."
  info "Source: $TASCTL_RAW"

  local tmp
  tmp=$(mktemp)

  if curl -fsSL "$TASCTL_RAW" -o "$tmp"; then
    chmod +x "$tmp"
    if head -1 "$tmp" | grep -q "bash"; then
      mv "$tmp" "$TASCTL_SYMLINK"
      ok "tasctl updated successfully!"
      info "Location: $TASCTL_SYMLINK"
    else
      rm -f "$tmp"
      err "Downloaded file does not look like a valid bash script."
    fi
  else
    rm -f "$tmp"
    err "Failed to download tasctl. Check your internet connection."
  fi

  printf "\n"
}

usage() {
  banner
  printf "%sUSAGE%s\n" "$CYAN$B" "$R"
  printf "  %s%s%s %s<command>%s\n\n" "$CYAN" "$CTL_NAME" "$R" "$B" "$R"

  printf "%sCOMMANDS%s\n" "$CYAN$B" "$R"
  printf "  %sinstall%s      Install Termux App Store (latest)\n" "$GREEN$B" "$R"
  printf "  %supdate%s       Update to latest version\n" "$GREEN$B" "$R"
  printf "  %suninstall%s    Remove Termux App Store\n" "$GREEN$B" "$R"
  printf "  %sdoctor%s       Diagnose environment\n" "$GREEN$B" "$R"
  printf "  %sself-update%s  Update tasctl itself\n" "$GREEN$B" "$R"
  printf "  %shelp%s         Show this help\n" "$GREEN$B" "$R"

  printf "\n%sEXAMPLES%s\n" "$CYAN$B" "$R"
  printf "  %s%s install%s\n" "$DIM" "$CTL_NAME" "$R"
  printf "  %s%s update%s\n" "$DIM" "$CTL_NAME" "$R"
  printf "  %s%s doctor%s\n" "$DIM" "$CTL_NAME" "$R"
  printf "  %s%s self-update%s\n" "$DIM" "$CTL_NAME" "$R"
  printf "\n"
}

cmd="${1:-help}"

case "$cmd" in
  install)
    banner
    header "Install"
    install_app "install"
    ;;
  update)
    banner
    header "Update"
    install_app "update"
    ;;
  uninstall)
    uninstall_app
    ;;
  doctor)
    cmd_doctor
    ;;
  self-update|selfupdate)
    cmd_self_update
    ;;
  help|-h|--help)
    usage
    ;;
  *)
    err "Unknown command: '$cmd'  →  Run: $CTL_NAME help"
    ;;
esac
